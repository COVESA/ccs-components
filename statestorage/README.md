To build the state storage manager
$ go build

Command line examples to run the statestorage manager
$ ./statestorage statestorage.db vsspathlist.json  // to create the statestorage DB
or
$ ./statestorage statestorage.db  // to enter mapping data from another address space to VSS

The vehicle state storage is used in the Genivi CCS project as a buffer between the Data server and the Feeder, the latter retrieving the data from the underlying "native" vehicle signal subsystem.<br><br>
The state storage manager provides the following services in this context:<br>
1. The creation of the SQL database that realizes this buffer.<br>
2. Population of the database with the paths to all VSS nodes as defined at https://github.com/GENIVI/vehicle_signal_specification.<br>
3. Creation of a mapping between VSS paths and any "non-VSS" signal address space.<br><br>
The services 1. and 2. are performed by executing the state storage manager with the following two command line parameters:<br>
A. The path and name for the new SQL database. This should NOT point to an existing file.<br>
B. The path and name to a file containing all the VSS paths. An example of such a file is the vsspathlist.json. 
This file is generated by the Gen2 server at startup, see <a href="https://github.com/MEAE-GOT/W3C_VehicleSignalInterfaceImpl">W3C_VehicleSignalInterfaceImpl</a>, 
from where it should be copied to get alignment with the VSS tree used by the Gen2 server.
However, it can also be generated by the <a href="https://github.com/GENIVI/ccs-w3c-client/tree/master/ovds/client)">OVDS client</a>.<br><br>
The service 3. is performed by executing the state storage manager with one command line parameter:<br>
C. The path and name for an existing SQL database created by the state storage manager.
A dialogue is then started where the manager first asks for the name of the "non-VSS address space.<br>
The name provided can either lead to creation of a new mapping to be initiated, if the manager does not find a table with that name. 
The name should only consist of characters [a-z, A-Z, 0-9].
If it finds a table with the name, it assumes that the user wants to map further VSS signals to signals in this address space.<br>
The dialogue supporting the mapping is only providing the most essential functions:<br>
- Map a non-VSS text based "handle" to a VSS path that has not been mapped before.<br>
- Go to the next non-mapped VSS path<br>
- Search among non-mapped VSS path for a path to map.<br>
- Quit the dialogue.<br><br>
Mapping also supports storage of parameters for a linear scaling of the data. Linear scaling means a transformation y = A * x + B. 
The parameters A (scale) and B (offset) can be saved in the statestorage DB. The values must be entered as an integer or float value. If skipped the values A=1.0, B= 0 are stored.<br>
It is also possible to store the datatype of the VSS signal. The input is of string type, and any string value is accepted.<br>
The linear transformation data, and the data type are meant to be used by the feeder when entering data into the state storage, i. e. that the feeder may read this data from the DB, using the same handle as when writing the data to the DB. It is up to the feeder to do an eventual transformation, before entering the data, the statestorage does not handle that automatically.<br>
The datatype is also meant to be helpful information for the feeder. As data is input into he statestorage in string format, it is important for the feeder to format it correctly. Integers must not contain any decimals, or a decimal dot, while float/double must contain both.<br>
The manager does currently not support change of already mapped signals, or removal of entire "non-VSS" mapping tables. 
As the databae is a standard SQL database, standard SQL tools can be used for that.<br><br>

The VSS_MAP table has the fields shown below.<br>
signal_id | path | c_value | c_ts | d_value | d_ts<br>
where c_value/c_ts is the current datapoint, and d_value/d_ts is the desired datapoint.<br>
The reason for having both a current datapoint and a desired datapoint for the same signal is to support the VISSv2 paradigm for actuator signals, 
where writing to an actuator sets a desired value, while reading it returns the current value.<br>
So the server reads from the current datapoint, 
and (for actuators) writes to the desired datapoint. On the 'southbound' side of the statestorage the feeder reads from the desired datapoint, and writes to the current datapoint.<br>

The statestorage manager is not meant to be used when the database is used for transferring data from a non-VSS domain to the VSS domain. 
In the CSS context it is the Feeder in the non-VSS domain that writes data into the database, and the Data server that reads data in the VSS domain. 
The Feeder can be coded in any language, but the SQL query for writing into the database will look (more or less) the same in all languages.<br>
A help for the coding of a Feeder query, as it looks in a Go language context, are shown below. 
The non-VSS address space is in this example assumed to be called XXX, hence the table is named XXX_MAP.<br>
To get the linear transformation data, and the datatype:<br>
"SELECT scale, offset, data_type FROM XXX_MAP WHERE handle=?"<br>
Then, after mapping using the data read above, to get the signal_id associated to the non-VSS handle:<br>
"SELECT signal_id FROM XXX_MAP WHERE handle=?"<br>
Finally to write the value and timestamp:<br>
"UPDATE VSS_MAP SET c/d_value=?, c/d_ts=? WHERE signal_id=?"<br>
The timestamp should follow the ISO8601 format "YYYY-MM-DDTHH:MM:SS.ssssssZ", where the sub-second part is optional.<br>
In the case the feeder implements the VSS mapping without involving the XXX_MAP table, then a write query would use the VSS path explicitly:<br>
"UPDATE VSS_MAP SET c/d_value=?, c/d_ts=? WHERE path=?"<br>
without any previous reads from the DB.<br>
The c/d notion above means either c or d (current or desired), depending on whether it is performed by the server or the feeder. 
