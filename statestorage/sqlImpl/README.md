## SQLite state storage implementation

The state storage manager is used to generate the SQLite database that contains entries for all signals of the VSS tree.<br>
The definition of the VSS tree to be inserted into the DB is expected to be represented in a file containing a JSON representation of all leaf node paths of the VSS tree. 
Such a file is generated at start up by the VISSv2 server implementation at 
<a href="https://github.com/w3c/automotive-viss2">W3C CVII VISSv2 server implementation</a>, with the name vsspathlist.json.<br>
The SQLite DB file generated by the statestorage manager can be given any name, but if to be used in the mentioned server implementation it is expected to have the name "statestorage.db".<br>
The state storage manager also provides a possibility to add to the DB another table that can contain data to be used by a feeder if/when it needs to "scale and offset" a non-VSS signal to a VSS signal. This functionality is not mentioned in the general description of the state storage concept in the README found in the parent directory, and may not be of interest to most developers of these systems. However, it is described below how to use the state storage manager to configure and populate the DB with such data.<br>

To build the state storage manager<br>
$ go build<br>

Command line examples to run the statestorage manager<br>
$ ./statestorage statestorage.db vsspathlist.json  // to create the statestorage DB<br>
or
$ ./statestorage statestorage.db  // to enter mapping data from another address space to VSS<br>

The state storage manager provides the following services in this context:<br>
1. The creation of the SQL database that realizes this buffer.<br>
2. Population of the database with the paths to all VSS nodes as defined at https://github.com/GENIVI/vehicle_signal_specification.<br>
3. Creation of a mapping between VSS paths and any "non-VSS" signal address space.<br><br>
The services 1. and 2. are performed by executing the state storage manager with the following two command line parameters:<br>
A. The path and name for the new SQL database. This should NOT point to an existing file.<br>
B. The path and name to a file containing all the VSS paths. An example of such a file is the vsspathlist.json. 
This file is generated by the Gen2 server at startup, see <a href="https://github.com/MEAE-GOT/W3C_VehicleSignalInterfaceImpl">W3C_VehicleSignalInterfaceImpl</a>, 
from where it should be copied to get alignment with the VSS tree used by the Gen2 server.
However, it can also be generated by the <a href="https://github.com/GENIVI/ccs-w3c-client/tree/master/ovds/client)">OVDS client</a>.<br><br>
The service 3. is performed by executing the state storage manager with one command line parameter:<br>
C. The path and name for an existing SQL database created by the state storage manager.
A dialogue is then started where the manager first asks for the name of the "non-VSS address space.<br>
The name provided can either lead to creation of a new mapping to be initiated, if the manager does not find a table with that name. 
The name should only consist of characters [a-z, A-Z, 0-9].
If it finds a table with the name, it assumes that the user wants to map further VSS signals to signals in this address space.<br>
The dialogue supporting the mapping is only providing the most essential functions:<br>
- Map a non-VSS text based "handle" to a VSS path that has not been mapped before.<br>
- Go to the next non-mapped VSS path<br>
- Search among non-mapped VSS path for a path to map.<br>
- Quit the dialogue.<br><br>
Mapping also supports storage of parameters for a linear scaling of the data. Linear scaling means a transformation y = A * x + B. 
The parameters A (scale) and B (offset) can be saved in the statestorage DB. The values must be entered as an integer or float value. If skipped the values A=1.0, B= 0 are stored.<br>
It is also possible to store the datatype of the VSS signal. The input is of string type, and any string value is accepted.<br>
The linear transformation data, and the data type are meant to be used by the feeder when entering data into the state storage, i. e. that the feeder may read this data from the DB, using the same handle as when writing the data to the DB. It is up to the feeder to do an eventual transformation, before entering the data, the statestorage does not handle that automatically.<br>
The datatype is also meant to be helpful information for the feeder. As data is input into he statestorage in string format, it is important for the feeder to format it correctly. Integers must not contain any decimals, or a decimal dot, while float/double must contain both.<br>
The manager does currently not support change of already mapped signals, or removal of entire "non-VSS" mapping tables. 
As the databae is a standard SQL database, standard SQL tools can be used for that.<br><br>

The VSS_MAP table has the fields shown below.<br>
signal_id | path | c_value | c_ts | d_value | d_ts<br>
where c_value/c_ts is the current datapoint, and d_value/d_ts is the desired datapoint.<br>
The reason for having both a current datapoint and a desired datapoint for the same signal is to support the VISSv2 paradigm for actuator signals, 
where writing to an actuator sets a desired value, while reading it returns the current value.<br>
So the server reads from the current datapoint, 
and (for actuators) writes to the desired datapoint. On the 'southbound' side of the statestorage the feeder reads from the desired datapoint, and writes to the current datapoint.<br>

The statestorage manager is not meant to be used when the database is used for transferring data from a non-VSS domain to the VSS domain. 
In the CSS context it is the Feeder in the non-VSS domain that writes data into the database, and the Data server that reads data in the VSS domain. 
The Feeder can be coded in any language, but the SQL query for writing into the database will look (more or less) the same in all languages.<br>
A help for the coding of a Feeder query, as it looks in a Go language context, are shown below. 
The non-VSS address space is in this example assumed to be called XXX, hence the table is named XXX_MAP.<br>
To get the linear transformation data, and the datatype:<br>
"SELECT scale, offset, data_type FROM XXX_MAP WHERE handle=?"<br>
Then, after mapping using the data read above, to get the signal_id associated to the non-VSS handle:<br>
"SELECT signal_id FROM XXX_MAP WHERE handle=?"<br>
Finally to write the value and timestamp:<br>
"UPDATE VSS_MAP SET c/d_value=?, c/d_ts=? WHERE signal_id=?"<br>
The timestamp should follow the ISO8601 format "YYYY-MM-DDTHH:MM:SS.ssssssZ", where the sub-second part is optional.<br>
In the case the feeder implements the VSS mapping without involving the XXX_MAP table, then a write query would use the VSS path explicitly:<br>
"UPDATE VSS_MAP SET c/d_value=?, c/d_ts=? WHERE path=?"<br>
without any previous reads from the DB.<br>
The c/d notion above means either c or d (current or desired), depending on whether it is performed by the server or the feeder. 

## Implementation of the getDataPoint() method
The implementations to be used by the server and the feeder(s) differ on the SQLite statement. In the following code template the feeder statement is commented out. 
To use this in a feeder, uncomment and instead comment the not commented SQLite statement.<br>
```
import  _ "github.com/mattn/go-sqlite3"

func GetDataPoint(path string) (string, string) {
	rows, err := db.Query("SELECT `c_value`, `c_ts` FROM VSS_MAP WHERE `path`=?", path)  // current datapoint
//	rows, err := db.Query("SELECT `d_value`, `d_ts` FROM VSS_MAP WHERE `path`=?", path)  // desired datapoint
	if err != nil {
		return "", ""
	}
	defer rows.Close()
	value := ""
	timestamp := ""
		rows.Next()
	err = rows.Scan(&value, &timestamp)
	if err != nil {
		return "", ""
	}
	return value, timestamp
}
```

## Implementation of the method setDataPoint() method
The implementations to be used by the server and the feeder(s) differ on the SQLite statement. In the following code template the feeder statement is commented out. 
To use this in a feeder, uncomment and instead comment the not commented SQLite statement.<br>
```
import  _ "github.com/mattn/go-sqlite3"

func SetDataPoint(path string, val string, ts string) string {
	stmt, err := db.Prepare("UPDATE VSS_MAP SET d_value=?, d_ts=? WHERE `path`=?")  // desired datapoint
//	stmt, err := db.Prepare("UPDATE VSS_MAP SET c_value=?, c_ts=? WHERE `path`=?")  // current datapoint
	if err != nil {
		return ""
	}
	defer stmt.Close()
		ts := utils.GetRfcTime()
	_, err = stmt.Exec(value, ts, path)
	if err != nil {
		return ""
	}
	return ts
}
```

## Implementation of the initStateStorage() method

```
import  _ "github.com/mattn/go-sqlite3"

func initStateStorage(dbPath string) *sql.DB {
		db, err := sql.Open("sqlite3", dbPath)
		if err != nil {
			return nil
		}
		return db
}
```

